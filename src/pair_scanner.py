{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "85dda3bc-c0d3-47fb-82ed-2de2e68e25ae",
   "metadata": {},
   "outputs": [],
   "source": [
    "import datetime\n",
    "import itertools\n",
    "from collections import Counter\n",
    "from typing import List, Dict, Any, Optional\n",
    "\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import yfinance as yf\n",
    "\n",
    "\n",
    "def fetch_ticker_data(ticker: str,\n",
    "                      start_date: datetime.date,\n",
    "                      end_date: datetime.date) -> Optional[pd.DataFrame]:\n",
    "    \"\"\"\n",
    "    Fetch historical OHLCV data for a given ticker between start_date and end_date.\n",
    "    Uses yfinance and returns a DataFrame indexed by date.\n",
    "\n",
    "    Returns None if no data is found or an error occurs.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        data = yf.download(\n",
    "            ticker,\n",
    "            start=start_date,\n",
    "            end=end_date,\n",
    "            auto_adjust=False,\n",
    "            progress=False,\n",
    "        )\n",
    "        if data.empty:\n",
    "            print(f\"[WARN] Data for {ticker} not found (empty DataFrame).\")\n",
    "            return None\n",
    "        return data\n",
    "    except Exception as e:\n",
    "        print(f\"[ERROR] Error fetching data for {ticker}: {e}\")\n",
    "        return None\n",
    "\n",
    "\n",
    "def analyze_ticker_pairs(\n",
    "    tickers: List[str],\n",
    "    start_date: datetime.date,\n",
    "    end_date: datetime.date,\n",
    "    output_file: str = \"pair_trade_messages.txt\",\n",
    ") -> Dict[str, Any]:\n",
    "    \"\"\"\n",
    "    Analyze all unique pairs of tickers over the given date range.\n",
    "\n",
    "    For each pair:\n",
    "      - Resamples to weekly adjusted close\n",
    "      - Builds the spread (ticker1 - ticker2)\n",
    "      - Computes correlation, z-score, a simple mean-reversion probability proxy\n",
    "      - Checks whether current spread is near historical max or min level\n",
    "      - If so, records a trade signal and scores it\n",
    "\n",
    "    Results:\n",
    "      - Writes a human-readable summary to `output_file`\n",
    "      - Returns a dictionary with detailed results for reuse in notebooks or other code\n",
    "    \"\"\"\n",
    "    pair_scores: List[Dict[str, Any]] = []\n",
    "    long_positions: List[str] = []\n",
    "    short_positions: List[str] = []\n",
    "\n",
    "    for ticker1, ticker2 in itertools.combinations(tickers, 2):\n",
    "        data1 = fetch_ticker_data(ticker1, start_date, end_date)\n",
    "        data2 = fetch_ticker_data(ticker2, start_date, end_date)\n",
    "\n",
    "        if data1 is None or data2 is None:\n",
    "            continue\n",
    "\n",
    "        # Weekly resample using adjusted close\n",
    "        data1_weekly = data1[\"Adj Close\"].resample(\"W\").last()\n",
    "        data2_weekly = data2[\"Adj Close\"].resample(\"W\").last()\n",
    "\n",
    "        aligned_data = pd.concat([data1_weekly, data2_weekly], axis=1)\n",
    "        aligned_data.columns = [f\"{ticker1} Adj Close\", f\"{ticker2} Adj Close\"]\n",
    "        aligned_data.dropna(inplace=True)\n",
    "\n",
    "        if aligned_data.empty:\n",
    "            print(f\"[INFO] No overlapping weekly data between {ticker1} and {ticker2}.\")\n",
    "            continue\n",
    "\n",
    "        # Spread\n",
    "        spread = aligned_data[f\"{ticker1} Adj Close\"] - aligned_data[f\"{ticker2} Adj Close\"]\n",
    "        spread_df = pd.DataFrame(\n",
    "            {\n",
    "                \"Open\": spread,\n",
    "                \"High\": spread,\n",
    "                \"Low\": spread,\n",
    "                \"Close\": spread,\n",
    "            },\n",
    "            index=aligned_data.index,\n",
    "        )\n",
    "\n",
    "        highest_value = spread_df[\"Close\"].max()\n",
    "        lowest_value = spread_df[\"Close\"].min()\n",
    "        current_value = spread_df[\"Close\"].iloc[-1]\n",
    "\n",
    "        # Correlation\n",
    "        series1 = aligned_data[f\"{ticker1} Adj Close\"]\n",
    "        series2 = aligned_data[f\"{ticker2} Adj Close\"]\n",
    "        if len(series1) > 1 and len(series2) > 1:\n",
    "            correlation = series1.corr(series2)\n",
    "        else:\n",
    "            correlation = np.nan\n",
    "\n",
    "        # Z-score\n",
    "        spread_mean = spread.mean()\n",
    "        spread_std = spread.std()\n",
    "        if spread_std != 0:\n",
    "            z_score = (current_value - spread_mean) / spread_std\n",
    "        else:\n",
    "            z_score = 0.0\n",
    "\n",
    "        # Crude mean-reversion probability proxy\n",
    "        p_revert = 1 - abs(z_score) / 3\n",
    "        mean_reversion_prob = float(max(min(p_revert, 1), 0))\n",
    "\n",
    "        # Total score heuristic\n",
    "        total_score = (\n",
    "            abs(correlation) * 2\n",
    "            + mean_reversion_prob * 3\n",
    "            + abs(z_score) * 1\n",
    "        )\n",
    "\n",
    "        # Signal logic: \"near\" max or min (within 5%)\n",
    "        is_max_level = (highest_value - current_value) <= 0.05 * abs(highest_value)\n",
    "        is_min_level = (current_value - lowest_value) <= 0.05 * abs(lowest_value)\n",
    "\n",
    "        if is_max_level or is_min_level:\n",
    "            if is_max_level:\n",
    "                signal_type = \"Max level\"\n",
    "                risk = highest_value - current_value\n",
    "                reward = current_value - lowest_value\n",
    "                # Max level: ticker1 is SHORT, ticker2 is LONG\n",
    "                long_positions.append(ticker2)\n",
    "                short_positions.append(ticker1)\n",
    "            else:\n",
    "                signal_type = \"Min level\"\n",
    "                risk = current_value - lowest_value\n",
    "                reward = highest_value - current_value\n",
    "                # Min level: ticker1 is LONG, ticker2 is SHORT\n",
    "                long_positions.append(ticker1)\n",
    "                short_positions.append(ticker2)\n",
    "\n",
    "            message = (\n",
    "                f\"{ticker1} & {ticker2} pair trade reached its {signal_type}.\\n\"\n",
    "                f\"Risk = {risk:.2f}, Reward = {reward:.2f}\\n\"\n",
    "                f\"Correlation Coefficient (Dividend-Adjusted): {correlation:.2f}\\n\"\n",
    "                f\"Current Z-Score: {z_score:.2f}\\n\"\n",
    "                f\"Estimated Mean-Reversion Probability: {mean_reversion_prob * 100:.1f}%\\n\"\n",
    "                f\"Total Score: {total_score:.2f}\\n\\n\"\n",
    "            )\n",
    "\n",
    "            pair_scores.append(\n",
    "                {\n",
    "                    \"message\": message,\n",
    "                    \"total_score\": float(total_score),\n",
    "                    \"ticker1\": ticker1,\n",
    "                    \"ticker2\": ticker2,\n",
    "                    \"signal_type\": signal_type,\n",
    "                    \"correlation\": float(correlation),\n",
    "                    \"z_score\": float(z_score),\n",
    "                    \"mean_reversion_prob\": float(mean_reversion_prob),\n",
    "                    \"risk\": float(risk),\n",
    "                    \"reward\": float(reward),\n",
    "                    \"spread\": spread_df,\n",
    "                }\n",
    "            )\n",
    "\n",
    "    # Sort pairs by score\n",
    "    pair_scores.sort(key=lambda x: x[\"total_score\"], reverse=True)\n",
    "    sorted_messages = [pair[\"message\"] for pair in pair_scores]\n",
    "\n",
    "    # Position summary\n",
    "    long_counter = Counter(long_positions)\n",
    "    short_counter = Counter(short_positions)\n",
    "\n",
    "    sorted_longs = sorted(long_counter.items(), key=lambda x: (-x[1], x[0]))\n",
    "    sorted_shorts = sorted(short_counter.items(), key=lambda x: (-x[1], x[0]))\n",
    "\n",
    "    position_summary = \"\\n\" + \"=\" * 60 + \"\\n\"\n",
    "    position_summary += \"POSITION SUMMARY\\n\"\n",
    "    position_summary += \"=\" * 60 + \"\\n\\n\"\n",
    "\n",
    "    position_summary += \"LONGS:\\n\"\n",
    "    if sorted_longs:\n",
    "        for ticker, count in sorted_longs:\n",
    "            position_summary += f\"{ticker} ({count})\\n\"\n",
    "    else:\n",
    "        position_summary += \"None\\n\"\n",
    "\n",
    "    position_summary += \"\\nSHORTS:\\n\"\n",
    "    if sorted_shorts:\n",
    "        for ticker, count in sorted_shorts:\n",
    "            position_summary += f\"{ticker} ({count})\\n\"\n",
    "    else:\n",
    "        position_summary += \"None\\n\"\n",
    "\n",
    "    # Write to file (human-readable)\n",
    "    with open(output_file, \"w\") as file:\n",
    "        if sorted_messages:\n",
    "            file.write(\"PAIR TRADING SIGNALS - SORTED BY TOTAL SCORE (DESCENDING)\\n\")\n",
    "            file.write(\"=\" * 60 + \"\\n\\n\")\n",
    "            file.writelines(sorted_messages)\n",
    "            file.write(position_summary)\n",
    "        else:\n",
    "            file.write(\"No pair trading signals found for the given tickers.\\n\")\n",
    "\n",
    "    # Build result object for programmatic use\n",
    "    result = {\n",
    "        \"pair_signals\": pair_scores,\n",
    "        \"longs\": sorted_longs,\n",
    "        \"shorts\": sorted_shorts,\n",
    "        \"position_summary_text\": position_summary,\n",
    "    }\n",
    "\n",
    "    return result\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Simple CLI entry point for manual runs\n",
    "    tickers_input = input(\"Enter the tickers separated by commas: \")\n",
    "    tickers = [t.strip().upper() for t in tickers_input.split(\",\") if t.strip()]\n",
    "\n",
    "    end_date = datetime.date.today()\n",
    "    start_date = end_date - datetime.timedelta(days=5 * 365)\n",
    "\n",
    "    results = analyze_ticker_pairs(tickers, start_date, end_date)\n",
    "\n",
    "    if results[\"pair_signals\"]:\n",
    "        print(f\"\\nFound {len(results['pair_signals'])} pair trading signals.\")\n",
    "        print(\"Top 5 pairs by total score:\")\n",
    "        print(\"-\" * 80)\n",
    "        for i, pair in enumerate(results[\"pair_signals\"][:5], 1):\n",
    "            print(f\"{i}. {pair['ticker1']} & {pair['ticker2']} - Score: {pair['total_score']:.2f}\")\n",
    "            print(f\"   Signal: {pair['signal_type']}, Correlation: {pair['correlation']:.2f}\")\n",
    "            print(f\"   Z-Score: {pair['z_score']:.2f}, Mean-Reversion Prob: {pair['mean_reversion_prob'] * 100:.1f}%\")\n",
    "            print(f\"   Risk: {pair['risk']:.2f}, Reward: {pair['reward']:.2f}\")\n",
    "            print()\n",
    "\n",
    "        print(results[\"position_summary_text\"])\n",
    "    else:\n",
    "        print(\"No pair trading signals found for the given tickers.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4baf780b-c975-4c40-8964-1eba99e5b6ca",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python313Clean",
   "language": "python",
   "name": "python313clean"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
